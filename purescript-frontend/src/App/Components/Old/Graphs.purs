module App.Components.Old.Graphs where

-- import App.API (AttributiResponse, OverviewResponse, retrieveAttributi, retrieveOverview)
-- import App.AppMonad (AppMonad, log)
-- import App.Attributo (Attributo, descriptiveAttributoText, qualifiedAttributoName)
-- import App.Components.Echarts (echartsComponent)
-- import App.Components.ParentComponent (ChildInput, ParentError, parentComponent)
-- import App.HalogenUtils (classList, singleClass)
-- import App.JSONSchemaType (JSONSchemaType(..))
-- import App.Logging (LogLevel(..))
-- import App.Overview (OverviewRow, OverviewCell, findCellInRow)
-- import App.PlotType (PlotType(..))
-- import App.Route (Route(..), GraphsRouteInput, createLink)
-- import App.Utils (fanoutApplicative)
-- import Control.Applicative (pure, (<*>))
-- import Control.Bind ((>>=))
-- import Data.Argonaut (toNumber)
-- import Data.Array (filter, mapMaybe)
-- import Data.Eq ((==))
-- import Data.Foldable (find)
-- import Data.Functor ((<$>))
-- import Data.Maybe (Maybe(..), maybe)
-- import Data.Semigroup ((<>))
-- import Data.Show (show)
-- import Data.Symbol (SProxy(..))
-- import Data.Tuple (Tuple(..))
-- import Data.Unit (Unit, unit)
-- import Data.Void (Void, absurd)
-- import Effect.Aff.Class (class MonadAff)
-- import Effect.Timer (clearTimeout, setTimeout)
-- import Halogen as H
-- import Halogen.HTML as HH
-- import Halogen.HTML.Events as HE
-- import Halogen.HTML.Properties as HP
-- import Halogen.Query.EventSource (EventSource, Finalizer(..), effectEventSource, emit)
-- import Network.RemoteData (RemoteData(..), fromEither)
-- import Prelude (discard, bind)
-- import Routing.Hash (setHash)

-- -- Event source for a simple timer
-- timerEventSource :: forall m. MonadAff m => EventSource m Action
-- timerEventSource =
--   effectEventSource \emitter -> do
--     timerId <- setTimeout 5000 (emit emitter RefreshTimeout)
--     pure (Finalizer (clearTimeout timerId))

-- type State
--   = { xAxis :: Maybe Attributo
--     , yAxis :: Maybe Attributo
--     , overviewRows :: Array OverviewRow
--     , attributi :: Array Attributo
--     , plotType :: PlotType
--     }

-- type OpaqueSlot slot
--   = forall query. H.Slot query Void slot

-- type ChildSlots
--   = ( graphSlot :: OpaqueSlot Unit )

-- extractNumberFromCell :: OverviewCell -> Maybe Number
-- extractNumberFromCell cell = toNumber cell.value

-- extractPairFromRow :: Attributo -> Attributo -> OverviewRow -> Maybe (Array Number)
-- extractPairFromRow xaxis yaxis overviewRow = do
--   xcell <- findCellInRow (qualifiedAttributoName xaxis) overviewRow
--   ycell <- findCellInRow (qualifiedAttributoName yaxis) overviewRow
--   x <- toNumber xcell.value
--   y <- toNumber ycell.value
--   pure [ x, y ]

-- render :: State -> H.ComponentHTML Action ChildSlots AppMonad
-- render state =
--   let
--     isPlottable attributo = case attributo.typeSchema of
--       JSONNumber _ -> true
--       JSONInteger _ -> true
--       _ -> false

--     plottableAttributi = filter isPlottable state.attributi

--     makeAttributoOption :: forall w. (State -> Maybe Attributo) -> Attributo -> HH.HTML w Action
--     makeAttributoOption getter a = HH.option [ HP.value a.name, HP.selected ((qualifiedAttributoName <$> (getter state)) == Just (qualifiedAttributoName a)) ] [ HH.text (descriptiveAttributoText a) ]

--     generateXAxisChange attributoName = XAxisChange <$> find (\a -> a.name == attributoName) state.attributi

--     generateYAxisChange attributoName = YAxisChange <$> find (\a -> a.name == attributoName) state.attributi

--     chartData = do
--       xaxis <- state.xAxis
--       yaxis <- state.yAxis
--       let
--         dataPoints :: Array (Array Number)
--         dataPoints = mapMaybe (extractPairFromRow xaxis yaxis) state.overviewRows
--         headline = descriptiveAttributoText xaxis <> " vs. " <> descriptiveAttributoText yaxis
--       pure
--         { width: 600.0
--         , height: 400.0
--         , options:
--             { title: { text: headline }
--             , xAxis: {}
--             , yAxis: {}
--             , series:
--                 [ { name: headline
--                   , "type": show state.plotType
--                   , "data": dataPoints
--                   , "symbol": if state.plotType == Line then "none" else "circle"
--                   }
--                 ]
--             }
--         }

--     disabledAttribute axis =
--       [ HH.option
--           [ HP.value "", HP.disabled true, HP.selected true ]
--           [ HH.text ("Select " <> axis <> " axis") ]
--       ]
--   in
--     HH.div_
--       [ HH.h1_ [ HH.text "Graph Dashboard" ]
--       , HH.form_
--           [ HH.div [ singleClass "mb-3" ]
--               [ HH.label [ HP.for "x-axis", singleClass "form-label" ] [ HH.text "X Axis" ]
--               , HH.select
--                   [ classList [ "form-select", "form-control" ]
--                   , HP.id_ "x-axis"
--                   , HE.onValueChange generateXAxisChange
--                   ]
--                   (disabledAttribute "X" <> (makeAttributoOption (\s -> s.xAxis) <$> plottableAttributi))
--               ]
--           , HH.div
--               [ singleClass "mb-3" ]
--               [ HH.label [ HP.for "y-axis", singleClass "form-label" ] [ HH.text "Y Axis" ]
--               , HH.select
--                   [ classList [ "form-select", "form-control" ]
--                   , HP.id_ "y-axis"
--                   , HE.onValueChange generateYAxisChange
--                   ]
--                   (disabledAttribute "Y" <> (makeAttributoOption (\s -> s.yAxis) <$> plottableAttributi))
--               ]
--           , HH.div
--               [ singleClass "mb-3" ]
--               [ HH.label [ HP.for "plot-type", singleClass "form-label" ] [ HH.text "Plot Type: " ]
--               , HH.select
--                   [ classList [ "form-select", "form-control" ]
--                   , HP.id_ "plot-type"
--                   , HE.onValueChange (\x -> Just (if x == "line" then PlotTypeChange Line else PlotTypeChange Scatter))
--                   ]
--                   [ HH.option [ HP.value (show Line), HP.selected (state.plotType == Line) ] [ HH.text "Line" ]
--                   , HH.option [ HP.value (show Scatter), HP.selected (state.plotType == Scatter) ] [ HH.text "Scatter" ]
--                   ]
--               ]
--           -- This is the much nicer radio button, but it doesn't work for some reason
--           -- , HH.div [ classList [ "btn-group", "btn-group-toggle" ], HP.attr (HH.AttrName "data-toggle") "buttons" ]
--           --     [ HH.label [ classList [ "btn", "btn-secondary", "active" ] ]
--           --         [ HH.input
--           --             [ HP.type_ InputRadio
--           --             , HP.name "plot-type"
--           --             , HP.id_ "line-plot"
--           --             , HP.checked (state.plotType == Line)
--           --             , HP.value "line"
--           --             , HE.onChange (const (Just (PlotTypeChange Line)))
--           --             --, HE.onValueInput (const (Just (PlotTypeChange Line)))
--           --             ]
--           --         , HH.text "Line plot"
--           --         ]
--           --     , HH.label [ classList [ "btn", "btn-secondary" ] ]
--           --         [ HH.input
--           --             [ HP.type_ InputRadio
--           --             , HP.name "plot-type"
--           --             , HP.id_ "scatter-plot"
--           --             , HP.checked (state.plotType == Scatter)
--           --             , HP.value "scatter"
--           --             , HE.onChange (const (Just (PlotTypeChange Scatter)))
--           --             --, HE.onValueInput (const (Just (PlotTypeChange Scatter)))
--           --             ]
--           --         , HH.text "Scatter plot"
--           --         ]
--           --     ]
--           -- ]
--           ]
--       , maybe (HH.text "Select both axes to plot!")
--           ( \chartData' ->
--               HH.slot
--                 (SProxy :: _ "graphSlot")
--                 unit
--                 (echartsComponent chartData')
--                 chartData'
--                 absurd
--           )
--           chartData
--       ]

-- childComponent :: forall q. H.Component HH.HTML q (ChildInput GraphsRouteInput ParentOutput) ParentError AppMonad
-- childComponent =
--   H.mkComponent
--     { initialState
--     , render
--     , eval:
--         H.mkEval
--           H.defaultEval
--             { initialize = Just Initialize
--             , handleAction = handleAction
--             }
--     }

-- data Action
--   = XAxisChange Attributo
--   | YAxisChange Attributo
--   | PlotTypeChange PlotType
--   | Initialize
--   | RefreshTimeout

-- routeInputFromState :: State -> GraphsRouteInput
-- routeInputFromState oldState =
--   { xAxis: qualifiedAttributoName <$> oldState.xAxis
--   , yAxis: qualifiedAttributoName <$> oldState.yAxis
--   , plotType: oldState.plotType
--   }

-- updateHash :: forall slots. H.HalogenM State Action slots ParentError AppMonad Unit
-- updateHash = do
--   oldState <- H.get
--   H.liftEffect (setHash (createLink (Graphs (routeInputFromState oldState))))

-- handleAction :: forall slots. Action -> H.HalogenM State Action slots ParentError AppMonad Unit
-- handleAction = case _ of
--   Initialize -> do
--     _ <- H.subscribe timerEventSource
--     pure unit
--   XAxisChange a -> do
--     H.modify_ \state -> state { xAxis = Just a }
--     updateHash
--   YAxisChange a -> do
--     H.modify_ \state -> state { yAxis = Just a }
--     updateHash
--   PlotTypeChange newType -> do
--     H.modify_ \state -> state { plotType = newType }
--     updateHash
--   RefreshTimeout -> do
--     H.lift (log Info "Refreshing...")
--     s <- H.get
--     remoteData <- H.lift (fetchData (routeInputFromState s))
--     case remoteData of
--       Success (Tuple newOverviewRows newAttributi) ->
--         H.modify_ \state ->
--           state
--             { overviewRows = newOverviewRows.overviewRows
--             , attributi = newAttributi.attributi
--             }
--       _ -> pure unit
--     _ <- H.subscribe timerEventSource
--     pure unit

-- initialState :: ChildInput GraphsRouteInput (Tuple OverviewResponse AttributiResponse) -> State
-- initialState { input: { xAxis, yAxis, plotType }, remoteData: Tuple overviewResponse attributiResponse } =
--   { overviewRows: overviewResponse.overviewRows
--   , attributi: attributiResponse.attributi
--   , xAxis: xAxis >>= \axis -> find (\a -> qualifiedAttributoName a == axis) attributiResponse.attributi
--   , yAxis: yAxis >>= \axis -> find (\a -> qualifiedAttributoName a == axis) attributiResponse.attributi
--   , plotType
--   }

-- type ParentOutput
--   = Tuple OverviewResponse AttributiResponse

-- -- Fetch runs and attributi
-- fetchData :: GraphsRouteInput -> AppMonad (RemoteData String ParentOutput)
-- fetchData _ = fromEither <$> (fanoutApplicative <$> retrieveOverview Nothing <*> retrieveAttributi)

-- component ::
--   forall query output.
--   H.Component HH.HTML query
--     GraphsRouteInput
--     output
--     AppMonad
-- component = parentComponent fetchData childComponent
