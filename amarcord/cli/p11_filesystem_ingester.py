import datetime
import logging
import sys
from dataclasses import replace
from math import ceil
from pathlib import Path
from time import sleep
from time import time
from typing import Dict
from typing import List
from typing import Optional
from typing import Set
from typing import Tuple
from typing import Union

import sqlalchemy as sa
from pint import UnitRegistry
from tap import Tap
from tqdm import tqdm

from amarcord.amici.p11.analysis_result import AnalysisResult
from amarcord.amici.p11.analyze_filesystem import P11Crystal
from amarcord.amici.p11.analyze_filesystem import P11Run
from amarcord.amici.p11.analyze_filesystem import parse_p11_crystals
from amarcord.amici.p11.db_ingest import EIGER_16_M_DETECTOR_NAME
from amarcord.amici.p11.db_ingest import empty_metadata_retriever
from amarcord.amici.p11.db_ingest import ingest_diffractions_for_crystals
from amarcord.amici.p11.db_ingest import ingest_reductions_for_crystals
from amarcord.amici.p11.run_key import RunKey
from amarcord.amici.p11.spreadsheet_reader import CrystalLine
from amarcord.amici.p11.spreadsheet_reader import metadata_retriever_from_lines
from amarcord.amici.p11.spreadsheet_reader import read_crystal_spreadsheet
from amarcord.amici.staraniso.parser import parse_staraniso_directory
from amarcord.amici.xds.analyze_filesystem import XDSFilesystemError
from amarcord.amici.xds.analyze_filesystem import analyze_xds_filesystem
from amarcord.modules.dbcontext import Connection
from amarcord.modules.dbcontext import CreationMode
from amarcord.modules.dbcontext import DBContext
from amarcord.newdb.db_crystal import DBCrystal
from amarcord.newdb.newdb import NewDB
from amarcord.newdb.tables import DBTables
from amarcord.newdb.tables import SeparateSchemata
from amarcord.util import find_by

DUMMY_PUCK_ID = "P1"

logging.basicConfig(
    format="%(asctime)-15s %(levelname)s %(message)s", level=logging.INFO
)

logger = logging.getLogger(__name__)


class Arguments(Tap):
    db_connection_url: str  # Connection URL for the database (e.g. pymysql+mysql://foo/bar)
    db_echo: bool = False  # output SQL statements?
    force_diffraction_ingest: bool = (
        False  # force creation of (successful) diffractions if missing
    )
    p11_proposal_path: str  # Path to the proposal root
    detector_name: str = EIGER_16_M_DETECTOR_NAME  # Detector name to use in the diffractions (if non-existant)
    crystal_spreadsheet: Optional[
        str
    ] = None  # Path to a spreadsheet file containing crystal information
    crystal_creation_date: Optional[
        str
    ] = None  # Creation date for newly created crystals (format YYYY-MM-DD)
    ignore_diffraction_warnings: bool = (
        False  # Ignore warnings related to ingestion of diffractions
    )
    ignore_reduction_warnings: bool = (
        False  # Ignore warnings related to ingestion of reductions
    )
    ignore_spreadsheet_warnings: bool = (
        False  # Ignore warnings related spreadsheet results
    )
    ignore_db_warnings: bool = False  # Ignore warnings related to ingestion to the DB
    dry_run: bool = False  # Dry run, don't commit the results
    create_crystals: bool = (
        False  # Create crystals if they don't exist (just for debugging purposes)
    )
    skip_diffractions: bool = False  # Whether to update diffractions found
    main_schema: Optional[str] = None
    analysis_schema: Optional[str] = None
    ingest_xdsapp: bool = (
        False  # Whether to ingest the XDSapp results (autogenerated by P11)
    )
    oneshot: bool = (
        False  # Whether to continuously scan the filesystem or do it just once
    )
    staraniso_path: Optional[
        str
    ] = None  # Path to staraniso (autoproc) results. Can have placeholder "${cid}" for the crystal ID and "${rid}" for the run ID in it

    """Ingest P11 filesystem"""


def parse_staraniso_reductions_for_crystals(
    crystals: List[P11Crystal], path_builder: str
) -> Tuple[Dict[RunKey, AnalysisResult], List[str]]:
    processed_results: Dict[RunKey, AnalysisResult] = {}
    reduction_warnings: List[str] = []
    for crystal in tqdm(crystals):
        for r in crystal.runs:
            processed_path = Path(
                path_builder.replace("${cid}", crystal.crystal_id).replace(
                    "${rid}", f"{r.run_id:03}"
                )
            )
            if not processed_path.is_dir():
                reduction_warnings.append(
                    f"crystal {crystal.crystal_id}, run {r.run_id}: no staraniso path {processed_path}"
                )
                continue

            try:
                processed_results[
                    RunKey(crystal.crystal_id, r.run_id)
                ] = parse_staraniso_directory(processed_path)
            except Exception as e:
                reduction_warnings.append(f"{processed_path}: {e}")

    return processed_results, reduction_warnings


def parse_xds_reductions_for_crystals(
    crystals: List[P11Crystal],
) -> Tuple[Dict[RunKey, AnalysisResult], List[str]]:
    processed_results: Dict[RunKey, AnalysisResult] = {}
    reduction_warnings: List[str] = []
    for crystal in tqdm(crystals):
        for r in crystal.runs:
            processed_path = Path(
                str(r.run_path.resolve()).replace("/raw/", "/processed/")
            )
            if not processed_path.is_dir():
                continue
            filesystem_result = analyze_xds_filesystem(
                processed_path,
                UnitRegistry(),
            )
            if isinstance(filesystem_result, XDSFilesystemError):
                reduction_warnings.append(
                    f"invalid XDS ingest: {filesystem_result.message}"
                )
                if filesystem_result.log_file is not None:
                    reduction_warnings.append(f"log file {filesystem_result.log_file}")
            else:
                processed_results[
                    RunKey(crystal.crystal_id, r.run_id)
                ] = filesystem_result.to_result()
    return processed_results, reduction_warnings


def process_and_validate_with_spreadsheet(
    spreadsheet_lines: List[CrystalLine], crystals: List[P11Crystal]
) -> Tuple[List[P11Crystal], List[str]]:
    new_crystals: List[P11Crystal] = []
    spreadsheet_warnings: List[str] = []
    # First step: check for duplicate lines in the spreadsheet file
    for idx, line in enumerate(spreadsheet_lines):
        duplicate_line: Optional[Tuple[int, CrystalLine]] = find_by(
            list(enumerate(spreadsheet_lines[idx + 1 :])),
            # pylint: disable=cell-var-from-loop
            lambda csl: csl[1].name == line.name and csl[1].run_id == line.run_id,
        )

        if duplicate_line is not None:
            spreadsheet_warnings.append(
                f"line {idx+1} is a duplicate (same name {line.name} and run id {line.run_id} as row {duplicate_line[0]}, typo?)"
            )
    # Second step: Iterate over all known crystals from the filesystem, keep
    # track of the ones we have _not_ seen in the spreadsheet
    remaining_crystals = set((c.name, c.run_id) for c in spreadsheet_lines)
    for crystal in crystals:
        new_runs: List[P11Run] = []
        crystal_name: Optional[str] = None
        for run in crystal.runs:
            # Try to find the crystal in the spreadsheet
            crystal_spreadsheet_line = find_by(
                spreadsheet_lines,
                # pylint: disable=cell-var-from-loop
                lambda csl: csl.directory == crystal.crystal_id
                and csl.run_id == run.run_id,
            )
            if crystal_spreadsheet_line is None:
                spreadsheet_warnings.append(
                    f'The crystal and run on the filesystem path "{crystal.crystal_id}/{run.run_id}"couldn\'t be '
                    f"associated to a line from the spreadsheet"
                )
            else:
                if (
                    crystal_name is not None
                    and crystal_name != crystal_spreadsheet_line.name
                ):
                    spreadsheet_warnings.append(
                        f"different name for same crystal {crystal.crystal_id} given for two different runs, now at {run.run_id}"
                    )
                    new_runs.clear()
                    crystal_name = None
                    break
                crystal_name = crystal_spreadsheet_line.name
                new_runs.append(run)
                crystal_tuple = (
                    crystal_spreadsheet_line.name,
                    crystal_spreadsheet_line.run_id,
                )
                # Due to duplicate lines, we might not have this tuple in the collection anymore
                if crystal_tuple in remaining_crystals:
                    remaining_crystals.remove(
                        (crystal_spreadsheet_line.name, crystal_spreadsheet_line.run_id)
                    )
        if new_runs and crystal_name is not None:
            new_crystals.append(
                replace(crystal, crystal_id=crystal_name, runs=new_runs)
            )

    if remaining_crystals:
        spreadsheet_warnings.append(
            f"The following crystals/runs are in the spreadsheet, but not in the filesystem: {remaining_crystals}"
        )

    return new_crystals, spreadsheet_warnings


def _crystal_exists(
    conn: Connection, table_crystals_: sa.Table, crystal_id: str
) -> bool:
    return (
        conn.execute(
            sa.select([table_crystals_.c.crystal_id]).where(
                table_crystals_.c.crystal_id == crystal_id
            )
        ).fetchone()
        is not None
    )


def main_loop(
    args: Arguments,
    dbcontext: DBContext,
) -> Union[int, Tuple[List[P11Crystal], Dict[RunKey, List[AnalysisResult]]]]:
    crystal_creation_date_str = args.crystal_creation_date
    crystal_creation_date: datetime.datetime
    if crystal_creation_date_str is None:
        crystal_creation_date = datetime.datetime.now()
    else:
        crystal_creation_date = datetime.datetime.strptime(
            crystal_creation_date_str, "%Y-%m-%d"
        )

    logger.info("Analyzing filesystem...")
    crystals, warnings = parse_p11_crystals(Path(args.p11_proposal_path))

    if warnings:
        for warning in warnings:
            logger.warning(warning)
        if args.ignore_diffraction_warnings:
            logger.info("Skipping %s diffraction warning(s)", len(warnings))
        else:
            logger.warning(
                "There were warnings! Please check those carefully and then call with --ignore-diffraction-warnings to "
                "apply the results"
            )
            return 1
    logger.info(
        "Analyzing filesystem...done! %s crystal(s) found",
        len(crystals),
    )

    logger.info("Analyzing reductions...")
    reduction_results: Dict[RunKey, List[AnalysisResult]] = {}
    reduction_warnings: List[str] = []

    if args.ingest_xdsapp:
        logger.info("Searching for XDSapp results...")
        xds_reduction_results, xds_warnings = parse_xds_reductions_for_crystals(
            crystals
        )
        if xds_reduction_results.values():
            logger.info(
                "Found %s XDSapp reduction result(s)",
                len(xds_reduction_results.values()),
            )
        reduction_results.update({k: [v] for k, v in xds_reduction_results.items()})
        reduction_warnings.extend(xds_warnings)

    if args.staraniso_path is not None:
        logger.info("Searching for staraniso results...")
        if "${cid}" not in args.staraniso_path or "${rid}" not in args.staraniso_path:
            logger.warning(
                'We have a --staraniso-path "%s", but it doesn\'t contain the crystal ID "${cid}" and run ID "${'
                "rid}\", that can't be right!",
                args.staraniso_path,
            )
            return 10

        staraniso_results, staraniso_warnings = parse_staraniso_reductions_for_crystals(
            crystals, args.staraniso_path
        )
        if staraniso_results.values():
            logger.info(
                "Found %s staraniso reduction result(s)",
                len(staraniso_results.values()),
            )
        reduction_results.update({k: [v] for k, v in staraniso_results.items()})
        reduction_warnings.extend(staraniso_warnings)

    if reduction_warnings:
        for warning in reduction_warnings:
            logger.warning(warning)
        if args.ignore_reduction_warnings:
            logger.info("Skipping %s reduction warning(s)", len(reduction_warnings))
        else:
            logger.warning(
                "There were reduction warnings! Please check those carefully and then call with "
                "--ignore-reduction-warnings to apply the "
                "results "
            )
            return 2
    logger.info(
        "Analyzing reductions...done! %s reduction(s) found",
        len(reduction_results.keys()),
    )

    spreadsheet_lines: List[CrystalLine] = []
    if args.crystal_spreadsheet is not None:
        logger.info("Analyzing spreadsheet...")
        spreadsheet_lines = read_crystal_spreadsheet(Path(args.crystal_spreadsheet))
        new_crystals, spreadsheet_warnings = process_and_validate_with_spreadsheet(
            spreadsheet_lines, crystals
        )

        if spreadsheet_warnings:
            for warning in spreadsheet_warnings:
                logger.warning(warning)
            if args.ignore_spreadsheet_warnings:
                logger.info(
                    "skipping %s spreadsheet warning(s)", len(spreadsheet_warnings)
                )
            else:
                logger.warning(
                    "There were spreadsheet warnings! Please check those carefully and then call with "
                    "--ignore-spreadsheet-warnings to apply the "
                    "results "
                )
                return 5

        crystals = new_crystals
        logger.info("Analyzing spreadsheet...Done!")

    db = NewDB(
        dbcontext,
        DBTables(
            dbcontext.metadata,
            with_tools=False,
            with_estimated_resolution=False,
            schemata=SeparateSchemata.from_two_optionals(
                args.main_schema, args.analysis_schema
            ),
        ),
    )
    with db.connect() as conn:
        try:
            with conn.begin():
                logger.info("Ingesting into DB...")
                to_remove_crystal_ids: Set[str] = set()
                for crystal in crystals:
                    if not db.crystal_exists(conn, crystal.crystal_id):
                        if args.create_crystals:
                            logger.info("Creating crystal %s...", crystal.crystal_id)
                            db.insert_crystal(
                                conn,
                                DBCrystal(
                                    crystal.crystal_id, created=crystal_creation_date
                                ),
                            )
                        else:
                            to_remove_crystal_ids.add(crystal.crystal_id)

                if to_remove_crystal_ids:
                    logger.info(
                        "Removing %s crystal(s) which are not in the DB...",
                        len(to_remove_crystal_ids),
                    )
                    crystals = [
                        c for c in crystals if c.crystal_id not in to_remove_crystal_ids
                    ]

                diff_ingest_warnings: List[str] = []
                if not args.skip_diffractions:
                    logger.info("Ingesting diffractions...")
                    diff_ingest_warnings = ingest_diffractions_for_crystals(
                        conn,
                        db,
                        crystals,
                        args.crystal_spreadsheet is not None
                        or args.force_diffraction_ingest,
                        metadata_retriever=metadata_retriever_from_lines(
                            spreadsheet_lines, args.detector_name
                        )
                        if spreadsheet_lines
                        else empty_metadata_retriever(args.detector_name),
                    )
                    if diff_ingest_warnings:
                        for warning in diff_ingest_warnings:
                            logger.warning(warning)
                        if args.ignore_db_warnings:
                            logger.info(
                                "skipping %s diffraction ingest warnings",
                                len(diff_ingest_warnings),
                            )
                        else:
                            logger.warning(
                                "There were ingestion warnings! Please check those carefully and then call with "
                                "--ignore-db-warnings to apply the results"
                            )
                            return 3
                    logger.info(
                        "Ingesting diffractions...done!",
                    )
                logger.info("Ingesting reductions...")
                reduction_warnings = ingest_reductions_for_crystals(
                    conn,
                    db,
                    crystals,
                    reduction_results,
                )
                if reduction_warnings:
                    for warning in reduction_warnings:
                        logger.warning(warning)
                    if args.ignore_db_warnings:
                        logger.info(
                            "Skipping %s reduction ingest warning(s)",
                            len(reduction_warnings),
                        )
                    else:
                        logger.warning(
                            "There were reduction warnings! Please check those carefully and then call with "
                            "--ignore-db-warnings to apply the results"
                        )
                    return 4
                logger.info("Ingesting reductions...Done!")
                if args.dry_run or (
                    reduction_warnings
                    or diff_ingest_warnings
                    and not args.ignore_db_warnings
                ):
                    raise StopIteration()
                logger.info("Ingest complete!")
        except StopIteration:
            logger.info("Ingested the results as a dry-run!")
    return crystals, reduction_results


def main(args: Arguments) -> int:
    dbcontext = DBContext(args.db_connection_url, echo=args.db_echo)

    if args.db_connection_url.startswith("sqlite"):
        logger.info("Creating tables")
        dbcontext.create_all(CreationMode.CHECK_FIRST)

    while True:
        logger.info("=====================================")
        logger.info("==========STARTING INGEST============")
        logger.info("=====================================")
        before = time()
        result = main_loop(
            args,
            dbcontext,
        )
        after = time()
        if isinstance(result, int):
            return result
        if args.oneshot:
            return 0
        logger.info("=====================================")
        logger.info("==========FINISHED INGEST============")
        logger.info("=====================================")
        if after - before < 5:
            logger.info("Next iteration in %ss", ceil(5 - (after - before)))
            sleep(ceil(5 - (after - before)))


if __name__ == "__main__":
    sys.exit(main(Arguments(underscores_to_dashes=True).parse_args()))
